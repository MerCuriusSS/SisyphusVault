### 第一步：从“物理骨架”切入（确立坐标系）

不要直接看代码，先让 AI 帮你理清模块间的物理层级。

- **描述套路**： “我是一个零基础学习者，请帮我分析该项目的 `pom.xml` 依赖树。请告诉我：哪些是**核心业务模块**，哪些是**基础设施模块**，它们之间的调用方向是怎样的？”
    
- **目的**： 建立宏观地图，避免在 `common` 模块里找业务逻辑。
    

### 第二步：寻找“隐形纽带”（破解自动化迷宫）

当发现包名重合却有不同加载方式时，要针对“启动机理”提问。

- **描述套路**： “我发现 `admin` 启动类可以扫描到 `org.dromara` 包，但为什么 `common` 下的部分模块要专门写 `AutoConfiguration.imports`？这是否意味着它们与普通的 `@Component` 扫描有不同的**加载阶段**或**排序逻辑**？”
    
- **目的**： 引导 AI 解释 Spring Boot 的自动装配原理，区分“业务 Bean”与“框架插件”。
    

### 第三步：验证“解耦边界”（理解设计取舍）

通过“假设性破坏”来验证模块的独立性。

- **描述套路**： “如果我从 `admin` 的依赖中移除 `common-xxx` 模块，为什么主业务代码不会报 `ClassNotFound` 错误？这种**非侵入式设计**是通过 AOP 还是接口抽象实现的？”
    
- **目的**： 理解“弱依赖”和“横切关注点”，看清架构师是如何把日志、权限等功能“挂”在业务上的。
    

### 第四步：解构“扩展槽位”（掌握魔改能力）

深入到具体的配置类，理解框架预留的控制点。

- **描述套路**： “请分析 `xxxConfig` 类。它为什么使用 `@AutoConfiguration` 而不是 `@Configuration`？如果我想在不改动源码的前提下替换它的默认行为，它是通过 `@Primary` 还是 `@ConditionalOnMissingBean` 给开发者留出**扩展空间**的？”
    
- **目的**： 学习“默认实现 + 覆盖机制”，这是从“代码阅读者”转向“架构参与者”的关键。